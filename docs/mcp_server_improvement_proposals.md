# ClipCrow MCPサーバーへの改善要求

本プロジェクトでのクライアント実装（Deno + Gemini
SDK）を通じて得られた知見に基づき、ClipCrow
MCPサーバーへの改善要求をまとめました。
Geminiを含む多種多様なLLMクライアントに対して、より堅牢で開発者フレンドリーなサーバーになるために強く期待する事項です。

## 1. スキーマ定義の簡素化（LLMフレンドリーな設計）

**現状:**
一部のツール定義において、非常に詳細な記述や複雑な型定義（深いネスト、再帰的な構造、`anyOf`
等）が見られます。これらは本来正確な型表現のためには正しいものですが、Geminiを含む一部のLLMにおいては「状態数が多すぎる（Too
many
states）」としてAPIレベルで拒否されたり、トークンを大量に消費したりする原因となります。

**要求:**

- **説明文の簡潔化**: `description`
  はLLMが判断できる最小限の長さに留めてください（期待値:
  150文字以内）。長大なドキュメントはコンテキストウィンドウを圧迫します。
- **複合型の回避**: `anyOf`, `oneOf`, `allOf` などのJSON
  Schemaコンビネータは、LLMの関数呼び出し機能にとっては解釈が難しく、エラーの温床となります。可能な限りフラットなプロパティ定義に落とし込むことを強く求めます。
- **プロパティ説明の省略**: 変数名そのものが自己説明的である場合（例: `message`,
  `target_id`）、各プロパティごとの `description`
  は省略可能です。これにより、クライアント側での「間引き」処理が不要になります。

## 2. ID解決の柔軟性向上（UUID vs Serial No）

**現状:** `Send_message` などの主要ツールは、引数として厳密な UUID (`target_id`)
を要求します。しかし、LLMのコンテキスト（プロンプト等）には人間可読な「シリアル番号」のみが含まれているケースが多く、モデルがシリアル番号を誤ってUUIDとして渡してエラーになるケースが多発しました。

**要求:**

- **パラメータ名の変更 (`target_id` -> `target`)**:
  UUIDだけでなくシリアル番号も受け入れるようになるため、より汎用的な名称（例:
  `target`）への変更を期待します。
- **シリアル番号のネイティブサポート**: `target` フィールドが UUID
  とシリアル番号（整数）の両方を受け入れられるようロジックを拡張してください。
- **曖昧さの許容**:
  サーバー側で「数値が渡されたらシリアル番号として検索」「文字列ならUUIDとして検索」といった動的な解決を行うことで、クライアント側での「検索
  → 送信」というマルチターン処理を回避でき、UXが向上します。

## 3. Tool定義におけるターゲットタイプの自動推論とパラメータ削除

**現状:** `Send_message` の `target_type` には `records` や
`chats`、`external_links`
などが存在し、クライアント側で適切なタイプを指定する必要があります。しかし、Bot自身など境界線上のオブジェクトに対してタイプを選択するのは直感的ではなく、エラーの原因となりました。

**要求:**

- **ターゲットタイプの削除**: 混乱防止およびスキーマ簡素化のため、`target_type`
  パラメータ自体を**削除**することを強く求めます。
- **サーバー側での自動解決**:
  UUIDはシステム全体でユニークであり、シリアル番号はワークスペース内でユニークです。IDさえ渡されれば、サーバー側で対象テーブルを一意に特定できるはずです。クライアントからタイプを指定させるのではなく、サーバー側でIDに基づいた自動推論を行ってください。

## 4. 初期化レスポンスでのセッションID明示

**現状:** クライアントは `initialize` リクエストを送信後、レスポンスヘッダー
(`x-session-id`) または SSE の `endpoint`
イベントからセッションIDを抽出する必要があります。

**課題:** 本プロジェクトで採用した `@modelcontextprotocol/sdk` の
`StreamableHTTPClientTransport`
はこの処理を内部的に隠蔽してくれるため、SDK利用者にとっては大きな問題ではありません。しかし、SDKを使用しない軽量クライアントや、独自のHTTP実装を行う場合には、ヘッダー解析やSSE待機が必須となりハードルとなります。

**要求:** 汎用性を高めるため、`initialize` メソッドの成功レスポンス（JSON-RPC
result）内に、割り当てられた `mcpSessionId`
を明示的に含めることを期待します（優先度は低）。

```json
// レスポンス例案
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "mcpSessionId": "aedb303651144d63b0f6ea88baf94261",
    "capabilities": { ... },
    "serverInfo": { ... }
  }
}
```

これにより、クライアントは標準的な JSON-RPC
の戻り値としてIDを取得でき、ヘッダー解析やSSE待機が不要になります。

## 5. 結論

クライアント側（`serve.ts`）では「Scorched
Earth（焦土作戦）」戦略により、現状の複雑なスキーマを強制的に整形して対応しましたが、サーバー側で上記のような「LLMフレンドリー」な調整が行われれば、クライアント実装はよりシンプルになり、他のLLMモデルへの対応も容易になります。
