# ClipCrow MCPサーバーへの改善提案

本プロジェクトでのクライアント実装（Deno + Gemini
SDK）を通じて得られた知見に基づき、ClipCrow
MCPサーバーの改善提案を再構成しました。
Geminiを含む多種多様なLLMクライアントに対して、より堅牢で開発者フレンドリーなサーバーになるための提案です。

## 1. スキーマ定義の簡素化（LLMフレンドリーな設計）

**現状:**
一部のツール定義において、非常に詳細な記述や複雑な型定義（深いネスト、再帰的な構造、`anyOf`
等）が見られます。これらは本来正確な型表現のためには正しいものですが、Geminiを含む一部のLLMにおいては「状態数が多すぎる（Too
many
states）」としてAPIレベルで拒否されたり、トークンを大量に消費したりする原因となります。

**提案:**

- **説明文の簡潔化**: `description`
  はLLMが判断できる最小限の長さに留めてください（推奨:
  150文字以内）。長大なドキュメントはコンテキストウィンドウを圧迫します。
- **複合型の回避**: `anyOf`, `oneOf`, `allOf` などのJSON
  Schemaコンビネータは、LLMの関数呼び出し機能にとっては解釈が難しく、エラーの温床となります。可能な限りフラットなプロパティ定義に落とし込むことを推奨します。
- **プロパティ説明の省略**: 変数名そのものが自己説明的である場合（例: `message`,
  `target_id`）、各プロパティごとの `description`
  は省略可能です。これにより、クライアント側での「間引き」処理が不要になります。

## 2. ID解決の柔軟性向上（UUID vs Serial No）

**現状:** `Send_message` などの主要ツールは、引数として厳密な UUID (`target_id`)
を要求します。しかし、LLMのコンテキスト（プロンプト等）には人間可読な「シリアル番号」のみが含まれているケースが多く、モデルがシリアル番号を誤ってUUIDとして渡してエラーになるケースが多発しました。

**提案:**

- **シリアル番号のネイティブサポート**: `target_id` フィールドが UUID
  とシリアル番号（整数）の両方を受け入れられるようロジックを拡張してください。
- **曖昧さの許容**:
  サーバー側で「数値が渡されたらシリアル番号として検索」「文字列ならUUIDとして検索」といった動的な解決を行うことで、クライアント側での「検索
  → 送信」というマルチターン処理を回避でき、UXが向上します。

## 3. Tool定義におけるターゲットタイプの明確化

**現状:** `Send_message` の `target_type` には `records` や `chats`
が存在しますが、Bot自身へ送る場合にどちらを選択すべきかが直感的ではありませんでした（Botは
`external_links`
の一種であるが、感覚的にはチャット相手であるため）。これによりモデルが誤ったタイプを選択し、400エラーとなる事例がありました。

**提案:**

- **専用タイプの新設**: 例えば `bot_context` や `current_context`
  のような、迷いの生じにくいターゲットタイプを追加することを検討してください。
- **エラーメッセージの改善**: `record not found` だけでなく、「指定されたUUIDは
  `chats` テーブルには存在しませんが `records`
  テーブルには存在します」といったヒントを返すことで、LLM（および開発者）の自己修正を助けることができます。

## 4. 初期化レスポンスでのセッションID明示

**現状:** クライアントは `initialize` リクエストを送信後、レスポンスヘッダー
(`x-session-id`) または SSE の `endpoint`
イベントからセッションIDを抽出する必要があります。

**課題:** 本プロジェクトで採用した `@modelcontextprotocol/sdk` の
`StreamableHTTPClientTransport`
はこの処理を内部的に隠蔽してくれるため、SDK利用者にとっては大きな問題ではありません。しかし、SDKを使用しない軽量クライアントや、独自のHTTP実装を行う場合には、ヘッダー解析やSSE待機が必須となりハードルとなります。

**提案:** 汎用性を高めるため、`initialize` メソッドの成功レスポンス（JSON-RPC
result）内に、割り当てられた `sessionId`
を明示的に含めることを推奨します（優先度は低）。

```json
// レスポンス例案
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "sessionId": "aedb303651144d63b0f6ea88baf94261", // 追加: これがあればヘッダー解析不要
    "capabilities": { ... },
    "serverInfo": { ... }
  }
}
```

これにより、クライアントは標準的な JSON-RPC
の戻り値としてIDを取得でき、ヘッダー解析やSSE待機が不要になります。

## 5. 結論

クライアント側（`serve.ts`）では「Scorched
Earth（焦土作戦）」戦略により、現状の複雑なスキーマを強制的に整形して対応しましたが、サーバー側で上記のような「LLMフレンドリー」な調整が行われれば、クライアント実装はよりシンプルになり、他のLLMモデルへの対応も容易になります。
